{:rename-macros {}, :renames {}, :externs {Error {}}, :use-macros {maybe cats.monad.maybe}, :excludes #{}, :name cats.monad.maybe, :imports nil, :requires {p cats.protocols, cats.protocols cats.protocols, ctx cats.context, cats.context cats.context, util cats.util, cats.util cats.util}, :cljs.spec/speced-vars [], :uses nil, :defs {maybe->seq {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 246, :column 7, :end-line 246, :end-column 17, :arglists (quote ([m])), :doc "Given a maybe, return an empty seq if its nothing or a one-element seq\n  with its value if its not."}, :name cats.monad.maybe/maybe->seq, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 246, :end-line 246, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Given a maybe, return an empty seq if its nothing or a one-element seq\n  with its value if its not."}, t_cats$monad$maybe45436 {:num-fields 1, :protocols #{cats.protocols/Semigroup cats.protocols/MonadPlus cats.protocols/Monad cats.protocols/Functor cljs.core/IMeta cats.protocols/Foldable cats.protocols/Traversable cats.protocols/Monoid cats.protocols/Context cljs.core/IWithMeta cats.protocols/Applicative cats.protocols/MonadZero cats.protocols/Printable}, :name cats.monad.maybe/t_cats$monad$maybe45436, :file ".cljs_node_repl/cats/monad/maybe.cljc", :type true, :anonymous true, :column 3, :line 149, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, ->Nothing {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 61, :column 12, :end-line 61, :end-column 19, :internal-ctor true, :factory :positional, :arglists (quote ([]))}, :name cats.monad.maybe/->Nothing, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 19, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 61, :end-line 61, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, ->t_cats$monad$maybe45436 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cats.protocols/Semigroup cats.protocols/MonadPlus cats.protocols/Monad cats.protocols/Functor cljs.core/IMeta cats.protocols/Foldable cats.protocols/Traversable cats.protocols/Monoid cats.protocols/Context cljs.core/IWithMeta cats.protocols/Applicative cats.protocols/MonadZero cats.protocols/Printable}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta45437])), :file nil}, :protocols #{cats.protocols/Semigroup cats.protocols/MonadPlus cats.protocols/Monad cats.protocols/Functor cljs.core/IMeta cats.protocols/Foldable cats.protocols/Traversable cats.protocols/Monoid cats.protocols/Context cljs.core/IWithMeta cats.protocols/Applicative cats.protocols/MonadZero cats.protocols/Printable}, :name cats.monad.maybe/->t_cats$monad$maybe45436, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :method-params ([meta45437]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 149, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta45437])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, nothing {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 98, :column 7, :end-line 98, :end-column 14, :arglists (quote ([])), :doc "A Nothing type constructor."}, :name cats.monad.maybe/nothing, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 14, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "A Nothing type constructor."}, just {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 92, :column 7, :end-line 92, :end-column 11, :arglists (quote ([v])), :doc "A Just type constructor."}, :name cats.monad.maybe/just, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 92, :end-line 92, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "A Just type constructor."}, cat-maybes {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 261, :column 7, :end-line 261, :end-column 17, :arglists (quote ([coll])), :doc "Given a collection of maybes, return a sequence of the values\n  that the just's contain."}, :name cats.monad.maybe/cat-maybes, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 261, :end-line 261, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Given a collection of maybes, return a sequence of the values\n  that the just's contain."}, Nothing {:num-fields 0, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cats.protocols/Extract cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cats.protocols/Contextual cljs.core/IMap cljs.core/ILookup cats.protocols/Printable}, :name cats.monad.maybe/Nothing, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 19, :type true, :column 12, :internal-ctor true, :line 61, :record true, :end-line 61, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map-maybe {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 267, :column 7, :end-line 267, :end-column 16, :arglists (quote ([mf coll])), :doc "Given a maybe-returning function and a collection, map the function over\n  the collection returning the values contained in the just values of the\n  resulting collection."}, :name cats.monad.maybe/map-maybe, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 16, :method-params ([mf coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 267, :end-line 267, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf coll])), :doc "Given a maybe-returning function and a collection, map the function over\n  the collection returning the values contained in the just values of the\n  resulting collection."}, just? {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 103, :column 7, :end-line 103, :end-column 12, :arglists (quote ([v])), :doc "Returns true if `v` is an instance\n  of `Just` type."}, :name cats.monad.maybe/just?, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 12, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 103, :end-line 103, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Returns true if `v` is an instance\n  of `Just` type."}, nothing? {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 109, :column 7, :end-line 109, :end-column 15, :arglists (quote ([v])), :doc "Returns true if `v` is an instance\n  of `Nothing` type or is nil."}, :name cats.monad.maybe/nothing?, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 15, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 109, :end-line 109, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Returns true if `v` is an instance\n  of `Nothing` type or is nil."}, map->Nothing {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 61, :column 12, :end-line 61, :end-column 19, :internal-ctor true, :factory :map, :arglists (quote ([G__45421]))}, :name cats.monad.maybe/map->Nothing, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 19, :method-params ([G__45421]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 61, :end-line 61, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__45421]))}, ->Just {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 45, :column 12, :end-line 45, :end-column 16, :internal-ctor true, :factory :positional, :arglists (quote ([just]))}, :name cats.monad.maybe/->Just, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 16, :method-params ([just]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 45, :end-line 45, :max-fixed-arity 1, :fn-var true, :arglists (quote ([just]))}, from-maybe {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 117, :column 7, :end-line 117, :end-column 17, :arglists (quote ([mv] [mv default])), :doc "Return inner value from maybe monad.\n\n  This is a specialized version of `cats.core/extract`\n  for Maybe monad types that allows set up\n  the default value.\n\n  Let see some examples:\n\n      (from-maybe (just 1))\n      ;=> 1\n\n      (from-maybe (nothing))\n      ;=> nil\n\n      (from-maybe (nothing) 42)\n      ;=> 42\n  ", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mv] [mv default]), :arglists ([mv] [mv default]), :arglists-meta (nil nil)}}, :name cats.monad.maybe/from-maybe, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mv] [mv default]), :arglists ([mv] [mv default]), :arglists-meta (nil nil)}, :method-params ([mv] [mv default]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 117, :end-line 117, :max-fixed-arity 2, :fn-var true, :arglists ([mv] [mv default]), :doc "Return inner value from maybe monad.\n\n  This is a specialized version of `cats.core/extract`\n  for Maybe monad types that allows set up\n  the default value.\n\n  Let see some examples:\n\n      (from-maybe (just 1))\n      ;=> 1\n\n      (from-maybe (nothing))\n      ;=> nil\n\n      (from-maybe (nothing) 42)\n      ;=> 42\n  "}, maybe? {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 83, :column 7, :end-line 83, :end-column 13, :arglists (quote ([v])), :doc "Return true in case of `v` is instance\n  of Maybe monad."}, :name cats.monad.maybe/maybe?, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 13, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 83, :end-line 83, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Return true in case of `v` is instance\n  of Maybe monad."}, seq->maybe {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 238, :column 7, :end-line 238, :end-column 17, :arglists (quote ([coll])), :doc "Given a collection, return a nothing if its empty or a just with its\n  first element if its not."}, :name cats.monad.maybe/seq->maybe, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 238, :end-line 238, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Given a collection, return a nothing if its empty or a just with its\n  first element if its not."}, Just {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cats.protocols/Extract cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cats.protocols/Contextual cljs.core/IMap cljs.core/ILookup cats.protocols/Printable}, :name cats.monad.maybe/Just, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 16, :type true, :column 12, :internal-ctor true, :line 45, :record true, :end-line 45, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->Just {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 45, :column 12, :end-line 45, :end-column 16, :internal-ctor true, :factory :map, :arglists (quote ([G__45411]))}, :name cats.monad.maybe/map->Just, :variadic false, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 16, :method-params ([G__45411]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 45, :end-line 45, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__45411]))}, context {:name cats.monad.maybe/context, :file ".cljs_node_repl/cats/monad/maybe.cljc", :line 147, :column 1, :end-line 148, :end-column 10, :no-doc true, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 148, :column 3, :end-line 148, :end-column 10, :no-doc true}, :tag cats.monad.maybe/t_cats$monad$maybe45436}, +extract-just-xform+ {:no-doc true, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/monad/maybe.cljc", :line 256, :column 3, :end-line 256, :end-column 23, :private true, :no-doc true}, :private true, :name cats.monad.maybe/+extract-just-xform+, :file ".cljs_node_repl/cats/monad/maybe.cljc", :end-column 23, :column 1, :line 255, :end-line 256, :tag any}}, :cljs.spec/registry-ref [], :require-macros {cats.monad.maybe cats.monad.maybe}, :cljs.analyzer/constants {:seen #{:nothing :just ->Nothing :private :else cats.monad.maybe/->Just :ns :name just :file :end-column meta45437 :column :internal-ctor ->Just :positional :factory :line cats.monad.maybe :end-line :arglists :doc cats.monad.maybe/->Nothing :test}, :order [:just just cats.monad.maybe/->Nothing :ns :name :file :end-column :column :internal-ctor :factory :line :end-line :arglists :doc :test cats.monad.maybe ->Nothing :positional :private cats.monad.maybe/->Just ->Just :nothing :else meta45437]}, :doc "The Maybe monad implementation and helpers functions\n  for working with maybe related types.\n\n      (require '[cats.monad.maybe :as maybe])\n\n      (maybe/just 1)\n      ;; => #<Just [1]>\n  "}