{:rename-macros {}, :renames {}, :externs {Error {}}, :use-macros {alet cats.core, mlet cats.core}, :excludes #{when unless filter sequence}, :name cats.core, :imports nil, :requires {p cats.protocols, cats.protocols cats.protocols, clojure.set clojure.set, ctx cats.context, cats.context cats.context}, :cljs.spec/speced-vars [], :uses nil, :defs {arity {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 638, :column 8, :end-line 638, :end-column 13, :private true, :arglists (quote ([var]))}, :private true, :name cats.core/arity, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 13, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 638, :end-line 638, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var]))}, pure {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 54, :column 7, :end-line 54, :end-column 11, :arglists (quote ([v] [ctx v])), :doc "Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  ", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}}, :name cats.core/pure, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}, :method-params ([v] [ctx v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 54, :end-line 54, :max-fixed-arity 2, :fn-var true, :arglists ([v] [ctx v]), :doc "Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  "}, arglists {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 628, :column 8, :end-line 628, :end-column 16, :private true, :arglists (quote ([var]))}, :private true, :name cats.core/arglists, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 16, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 628, :end-line 628, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var]))}, foldl {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 948, :column 7, :end-line 948, :end-column 12, :arglists (quote ([f z xs])), :doc "Perform a left-associative fold on the data structure."}, :name cats.core/foldl, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 12, :method-params ([f z xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 948, :end-line 948, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f z xs])), :doc "Perform a left-associative fold on the data structure."}, as-ap-> {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 549, :column 11, :end-line 549, :end-column 18, :macro true, :arglists (quote ([expr name & forms])), :doc "Thread like `as->`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env expr name forms)], :arglists ([&form &env expr name & forms]), :arglists-meta (nil)}}, :name cats.core/as-ap->, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env expr name forms)], :arglists ([&form &env expr name & forms]), :arglists-meta (nil)}, :method-params [(&form &env expr name forms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 549, :macro true, :end-line 549, :max-fixed-arity 4, :fn-var false, :arglists ([&form &env expr name & forms]), :doc "Thread like `as->`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion."}, fapply {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 186, :column 7, :end-line 186, :end-column 13, :arglists (quote ([af & avs])), :doc "Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(af avs)], :arglists ([af & avs]), :arglists-meta (nil)}}, :name cats.core/fapply, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(af avs)], :arglists ([af & avs]), :arglists-meta (nil)}, :method-params [(af avs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 186, :end-line 186, :max-fixed-arity 1, :fn-var true, :arglists ([af & avs]), :doc "Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply."}, <*> {:name cats.core/<*>, :file ".cljs_node_repl/cats/core.cljc", :line 885, :column 1, :end-line 885, :end-column 9, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 885, :column 6, :end-line 885, :end-column 9}, :doc "A Haskell-style `fapply` alias."}, guard {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 110, :column 7, :end-line 110, :end-column 12, :arglists (quote ([b]))}, :name cats.core/guard, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 110, :end-line 110, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, ->= {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 561, :column 11, :end-line 561, :end-column 14, :macro true, :arglists (quote ([expr & forms])), :doc "Like `->`, but with monadic binding instead of pure application.\n   A mnemonic for the name is a pun on `>>=`, the monadic bind operator,\n   and clojure's regular arrow macros.\n\n   You can think of it as generalizing the `some->` thread macro\n   to all Monads instead of just Maybe.\n\n   Alternatively, if you think of the regular thread macro as\n   sugar for `let`:\n\n   (-> :a b (c (other args)) d)\n   =>\n   (let [res (b :a)\n         res (c res (other args))\n         res (d res)]\n     res)\n\n   Then `->=` is sugar for cats.core/mlet:\n\n   (->= m-a b (c (other args)) d)\n   (mlet [res m-a\n          res (c res (other args))\n          res (d res)]\n     (return res))\n\n   Note that extra args in this context are assumed pure, and will\n   be evaluated along with the function itself; this also matches\n   the behavior of `some->` wrt extra args.\n\n   Threading through pure functions is somewhat awkward, but can be done:\n\n   (->= m-a\n        monadic-fn\n        (-> pure-fn\n            other-pure-fn\n            m/return)\n        other-monadic-fn)", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr forms)], :arglists ([&form &env expr & forms]), :arglists-meta (nil)}}, :name cats.core/->=, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr forms)], :arglists ([&form &env expr & forms]), :arglists-meta (nil)}, :method-params [(&form &env expr forms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 561, :macro true, :end-line 561, :max-fixed-arity 3, :fn-var false, :arglists ([&form &env expr & forms]), :doc "Like `->`, but with monadic binding instead of pure application.\n   A mnemonic for the name is a pun on `>>=`, the monadic bind operator,\n   and clojure's regular arrow macros.\n\n   You can think of it as generalizing the `some->` thread macro\n   to all Monads instead of just Maybe.\n\n   Alternatively, if you think of the regular thread macro as\n   sugar for `let`:\n\n   (-> :a b (c (other args)) d)\n   =>\n   (let [res (b :a)\n         res (c res (other args))\n         res (d res)]\n     res)\n\n   Then `->=` is sugar for cats.core/mlet:\n\n   (->= m-a b (c (other args)) d)\n   (mlet [res m-a\n          res (c res (other args))\n          res (d res)]\n     (return res))\n\n   Note that extra args in this context are assumed pure, and will\n   be evaluated along with the function itself; this also matches\n   the behavior of `some->` wrt extra args.\n\n   Threading through pure functions is somewhat awkward, but can be done:\n\n   (->= m-a\n        monadic-fn\n        (-> pure-fn\n            other-pure-fn\n            m/return)\n        other-monadic-fn)"}, join {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 116, :column 7, :end-line 116, :end-column 11, :arglists (quote ([mv])), :doc "Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."}, :name cats.core/join, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 11, :method-params ([mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 116, :end-line 116, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mv])), :doc "Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."}, bimap {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 133, :column 7, :end-line 133, :end-column 12, :arglists (quote ([f g] [f g bv])), :doc "Map over both arguments at the same time.\n\n  Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\n  apply `f` to a first argument or `g` to a second argument.\n\n      (bimap dec inc (either/right 1)\n      ;; => #<Right 2>\n\n      (bimap dec inc (either/left 1)\n      ;; => #<Left 0>", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f g] [f g bv]), :arglists ([f g] [f g bv]), :arglists-meta (nil nil)}}, :name cats.core/bimap, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f g] [f g bv]), :arglists ([f g] [f g bv]), :arglists-meta (nil nil)}, :method-params ([f g] [f g bv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 133, :end-line 133, :max-fixed-arity 3, :fn-var true, :arglists ([f g] [f g bv]), :doc "Map over both arguments at the same time.\n\n  Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\n  apply `f` to a first argument or `g` to a second argument.\n\n      (bimap dec inc (either/right 1)\n      ;; => #<Right 2>\n\n      (bimap dec inc (either/left 1)\n      ;; => #<Left 0>"}, bind {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 81, :column 7, :end-line 81, :end-column 11, :arglists (quote ([mv f])), :doc "Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."}, :name cats.core/bind, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 11, :method-params ([mv f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 81, :end-line 81, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mv f])), :doc "Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."}, deps {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 274, :column 8, :end-line 274, :end-column 12, :private true, :arglists (quote ([expr syms]))}, :private true, :name cats.core/deps, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 12, :method-params ([expr syms]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 274, :end-line 274, :max-fixed-arity 2, :fn-var true, :arglists (quote ([expr syms]))}, topo-sort* {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 356, :column 8, :end-line 356, :end-column 18, :private true, :arglists (quote ([deps seen batches current]))}, :private true, :name cats.core/topo-sort*, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 18, :method-params ([deps seen batches current]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 356, :end-line 356, :max-fixed-arity 4, :fn-var true, :arglists (quote ([deps seen batches current]))}, <$> {:name cats.core/<$>, :file ".cljs_node_repl/cats/core.cljc", :line 881, :column 1, :end-line 881, :end-column 9, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 881, :column 6, :end-line 881, :end-column 9}, :doc "A Haskell-style `fmap` alias."}, <=< {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 924, :column 7, :end-line 924, :end-column 10, :arglists (quote ([mg mf x])), :doc "Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."}, :name cats.core/<=<, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 10, :method-params ([mg mf x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 924, :end-line 924, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mg mf x])), :doc "Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."}, alet* {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 386, :column 8, :end-line 386, :end-column 13, :private true, :arglists (quote ([batches env body]))}, :private true, :name cats.core/alet*, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 13, :method-params ([batches env body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 386, :end-line 386, :max-fixed-arity 3, :fn-var true, :arglists (quote ([batches env body]))}, single-arity? {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 632, :column 8, :end-line 632, :end-column 21, :private true, :arglists (quote ([var]))}, :private true, :name cats.core/single-arity?, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 21, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 632, :end-line 632, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var]))}, >>= {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 889, :column 7, :end-line 889, :end-column 10, :arglists (quote ([mv f] [mv f & fs])), :doc "Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv f]), :arglists ([mv f] [mv f & fs]), :arglists-meta (nil nil)}}, :name cats.core/>>=, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv f]), :arglists ([mv f] [mv f & fs]), :arglists-meta (nil nil)}, :method-params ([mv f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 889, :end-line 889, :max-fixed-arity 2, :fn-var true, :arglists ([mv f] [mv f & fs]), :doc "Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  "}, ap-> {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 513, :column 11, :end-line 513, :end-column 15, :macro true, :arglists (quote ([x & forms])), :doc "Thread like `->`, within an applicative idiom.\n\n  Compare:\n\n  (macroexpand-1 `(-> a b c (d e f)))\n  => (d (c (b a) e f)\n\n  with:\n\n  (macroexpand-1 `(ap-> a b c (d e f))\n  => (ap d (ap c (ap b a) e f))\n  ", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}}, :name cats.core/ap->, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}, :method-params [(&form &env x forms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 513, :macro true, :end-line 513, :max-fixed-arity 3, :fn-var false, :arglists ([&form &env x & forms]), :doc "Thread like `->`, within an applicative idiom.\n\n  Compare:\n\n  (macroexpand-1 `(-> a b c (d e f)))\n  => (d (c (b a) e f)\n\n  with:\n\n  (macroexpand-1 `(ap-> a b c (d e f))\n  => (ap d (ap c (ap b a) e f))\n  "}, mzero {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 98, :column 7, :end-line 98, :end-column 12, :arglists (quote ([] [ctx])), :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}}, :name cats.core/mzero, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}, :method-params ([] [ctx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 1, :fn-var true, :arglists ([] [ctx])}, return {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 75, :column 7, :end-line 75, :end-column 13, :arglists (quote ([v] [ctx v])), :doc "This is a monad version of `pure` and works\n  identically to it.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}}, :name cats.core/return, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}, :method-params ([v] [ctx v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 75, :end-line 75, :max-fixed-arity 2, :fn-var true, :arglists ([v] [ctx v]), :doc "This is a monad version of `pure` and works\n  identically to it."}, mappend {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 48, :column 7, :end-line 48, :end-column 14, :arglists (quote ([& svs])), :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(svs)], :arglists ([& svs]), :arglists-meta (nil)}}, :name cats.core/mappend, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(svs)], :arglists ([& svs]), :arglists-meta (nil)}, :method-params [(svs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 48, :end-line 48, :max-fixed-arity 0, :fn-var true, :arglists ([& svs])}, mapseq {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 811, :column 7, :end-line 811, :end-column 13, :arglists (quote ([mf coll])), :doc "Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (mapseq #(maybe/just (* % 2)) []))\n      ;; => #<Just [()]>\n  "}, :name cats.core/mapseq, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 13, :method-params ([mf coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 811, :end-line 811, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf coll])), :doc "Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (mapseq #(maybe/just (* % 2)) []))\n      ;; => #<Just [()]>\n  "}, mplus {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 104, :column 7, :end-line 104, :end-column 12, :arglists (quote ([& mvs])), :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(mvs)], :arglists ([& mvs]), :arglists-meta (nil)}}, :name cats.core/mplus, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(mvs)], :arglists ([& mvs]), :arglists-meta (nil)}, :method-params [(mvs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 104, :end-line 104, :max-fixed-arity 0, :fn-var true, :arglists ([& mvs])}, dedupe-symbols {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 334, :column 8, :end-line 334, :end-column 22, :private true, :arglists (quote ([bindings body]))}, :private true, :name cats.core/dedupe-symbols, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 22, :method-params ([bindings body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 334, :end-line 334, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bindings body]))}, as->= {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 616, :column 11, :end-line 616, :end-column 16, :macro true, :arglists (quote ([expr name & forms])), :doc "Like `as->`, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env expr name forms)], :arglists ([&form &env expr name & forms]), :arglists-meta (nil)}}, :name cats.core/as->=, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(&form &env expr name forms)], :arglists ([&form &env expr name & forms]), :arglists-meta (nil)}, :method-params [(&form &env expr name forms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 616, :macro true, :end-line 616, :max-fixed-arity 4, :fn-var false, :arglists ([&form &env expr name & forms]), :doc "Like `as->`, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion."}, >> {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 902, :column 7, :end-line 902, :end-column 9, :arglists (quote ([mv mv'] [mv mv' & mvs])), :doc "Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv mv']), :arglists ([mv mv'] [mv mv' & mvs]), :arglists-meta (nil nil)}}, :name cats.core/>>, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 9, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv mv']), :arglists ([mv mv'] [mv mv' & mvs]), :arglists-meta (nil nil)}, :method-params ([mv mv']), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 902, :end-line 902, :max-fixed-arity 2, :fn-var true, :arglists ([mv mv'] [mv mv' & mvs]), :doc "Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations."}, rename {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 291, :column 8, :end-line 291, :end-column 14, :private true, :arglists (quote ([expr renames]))}, :private true, :name cats.core/rename, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 14, :method-params ([expr renames]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 291, :end-line 291, :max-fixed-arity 2, :fn-var true, :arglists (quote ([expr renames]))}, ->>= {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 606, :column 11, :end-line 606, :end-column 15, :macro true, :arglists (quote ([expr & forms])), :doc "Like ->>, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr forms)], :arglists ([&form &env expr & forms]), :arglists-meta (nil)}}, :name cats.core/->>=, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env expr forms)], :arglists ([&form &env expr & forms]), :arglists-meta (nil)}, :method-params [(&form &env expr forms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 606, :macro true, :end-line 606, :max-fixed-arity 3, :fn-var false, :arglists ([&form &env expr & forms]), :doc "Like ->>, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion."}, rename-sym {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 287, :column 8, :end-line 287, :end-column 18, :private true, :arglists (quote ([expr renames]))}, :private true, :name cats.core/rename-sym, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 18, :method-params ([expr renames]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 287, :end-line 287, :max-fixed-arity 2, :fn-var true, :arglists (quote ([expr renames]))}, ap->> {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 536, :column 11, :end-line 536, :end-column 16, :macro true, :arglists (quote ([x & forms])), :doc "Thread like `->>`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}}, :name cats.core/ap->>, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env x forms)], :arglists ([&form &env x & forms]), :arglists-meta (nil)}, :method-params [(&form &env x forms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 536, :macro true, :end-line 536, :max-fixed-arity 3, :fn-var false, :arglists ([&form &env x & forms]), :doc "Thread like `->>`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion."}, traverse {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 997, :column 7, :end-line 997, :end-column 15, :arglists (quote ([f tv] [ctx f tv])), :doc "Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  ", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f tv] [ctx f tv]), :arglists ([f tv] [ctx f tv]), :arglists-meta (nil nil)}}, :name cats.core/traverse, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f tv] [ctx f tv]), :arglists ([f tv] [ctx f tv]), :arglists-meta (nil nil)}, :method-params ([f tv] [ctx f tv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 997, :end-line 997, :max-fixed-arity 3, :fn-var true, :arglists ([f tv] [ctx f tv]), :doc "Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  "}, forseq {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 837, :column 7, :end-line 837, :end-column 13, :arglists (quote ([vs mf])), :doc "Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "}, :name cats.core/forseq, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 13, :method-params ([vs mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 837, :end-line 837, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vs mf])), :doc "Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "}, =<< {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 910, :column 7, :end-line 910, :end-column 10, :arglists (quote ([f mv])), :doc "Same as the two argument version of `>>=` but with the\n  arguments flipped."}, :name cats.core/=<<, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 10, :method-params ([f mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 910, :end-line 910, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f mv])), :doc "Same as the two argument version of `>>=` but with the\n  arguments flipped."}, foldr {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 941, :column 7, :end-line 941, :end-column 12, :arglists (quote ([f z xs])), :doc "Perform a right-associative fold on the data structure."}, :name cats.core/foldr, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 12, :method-params ([f z xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 941, :end-line 941, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f z xs])), :doc "Perform a right-associative fold on the data structure."}, >=> {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 916, :column 7, :end-line 916, :end-column 10, :arglists (quote ([mf mg x])), :doc "Left-to-right composition of monads."}, :name cats.core/>=>, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 10, :method-params ([mf mg x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 916, :end-line 916, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf mg x])), :doc "Left-to-right composition of monads."}, dependency-map {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 341, :column 8, :end-line 341, :end-column 22, :private true, :arglists (quote ([sym->ap]))}, :private true, :name cats.core/dependency-map, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 22, :method-params ([sym->ap]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 341, :end-line 341, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym->ap]))}, <> {:name cats.core/<>, :file ".cljs_node_repl/cats/core.cljc", :line 939, :column 1, :end-line 939, :end-column 8, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 939, :column 6, :end-line 939, :end-column 8}}, right-map {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 169, :column 7, :end-line 169, :end-column 16, :arglists (quote ([g] [g bv])), :doc "Map covariantly over the second argument.\n\n  Given a function `g` and a value wrapped in a bifunctor `bv`,\n  apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\n\n      (right-map inc (either/right 1)\n      ;; => #<Right 2>\n\n      (right-map inc (either/left 1)\n      ;; => #<Left 1>", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([g] [g bv]), :arglists ([g] [g bv]), :arglists-meta (nil nil)}}, :name cats.core/right-map, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([g] [g bv]), :arglists ([g] [g bv]), :arglists-meta (nil nil)}, :method-params ([g] [g bv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 169, :end-line 169, :max-fixed-arity 2, :fn-var true, :arglists ([g] [g bv]), :doc "Map covariantly over the second argument.\n\n  Given a function `g` and a value wrapped in a bifunctor `bv`,\n  apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\n\n      (right-map inc (either/right 1)\n      ;; => #<Right 2>\n\n      (right-map inc (either/left 1)\n      ;; => #<Left 1>"}, topo-sort {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 373, :column 8, :end-line 373, :end-column 17, :private true, :arglists (quote ([deps]))}, :private true, :name cats.core/topo-sort, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 17, :method-params ([deps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 373, :end-line 373, :max-fixed-arity 1, :fn-var true, :arglists (quote ([deps]))}, filter {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 857, :column 7, :end-line 857, :end-column 13, :arglists (quote ([p mv])), :doc "Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "}, :name cats.core/filter, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 13, :method-params ([p mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 857, :end-line 857, :max-fixed-arity 2, :fn-var true, :arglists (quote ([p mv])), :doc "Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "}, left-map {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 152, :column 7, :end-line 152, :end-column 15, :arglists (quote ([f] [f bv])), :doc "Map covariantly over the first argument.\n\n  Given a function `f` and a value wrapped in a bifunctor `bv`,\n  apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\n\n      (left-map dec (either/right 1)\n      ;; => #<Right 1>\n\n      (left-map dec (either/left 1)\n      ;; => #<Left 0>", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f bv]), :arglists ([f] [f bv]), :arglists-meta (nil nil)}}, :name cats.core/left-map, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f bv]), :arglists ([f] [f bv]), :arglists-meta (nil nil)}, :method-params ([f] [f bv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 152, :end-line 152, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f bv]), :doc "Map covariantly over the first argument.\n\n  Given a function `f` and a value wrapped in a bifunctor `bv`,\n  apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\n\n      (left-map dec (either/right 1)\n      ;; => #<Right 1>\n\n      (left-map dec (either/left 1)\n      ;; => #<Left 0>"}, dedupe-symbols* {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 301, :column 8, :end-line 301, :end-column 23, :private true, :arglists (quote ([sym->ap body]))}, :private true, :name cats.core/dedupe-symbols*, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 23, :method-params ([sym->ap body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 301, :end-line 301, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sym->ap body]))}, fmap {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 122, :column 7, :end-line 122, :end-column 11, :arglists (quote ([f] [f fv])), :doc "Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f fv]), :arglists ([f] [f fv]), :arglists-meta (nil nil)}}, :name cats.core/fmap, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f fv]), :arglists ([f] [f fv]), :arglists-meta (nil nil)}, :method-params ([f] [f fv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 122, :end-line 122, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f fv]), :doc "Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type."}, mempty {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 44, :column 7, :end-line 44, :end-column 13, :arglists (quote ([] [ctx])), :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}}, :name cats.core/mempty, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}, :method-params ([] [ctx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 44, :end-line 44, :max-fixed-arity 1, :fn-var true, :arglists ([] [ctx])}, remove-deps {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 350, :column 8, :end-line 350, :end-column 19, :private true, :arglists (quote ([deps symset]))}, :private true, :name cats.core/remove-deps, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 19, :method-params ([deps symset]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 350, :end-line 350, :max-fixed-arity 2, :fn-var true, :arglists (quote ([deps symset]))}, extract {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 933, :column 7, :end-line 933, :end-column 14, :arglists (quote ([v])), :doc "Generic function to unwrap/extract\n  the inner value of a container."}, :name cats.core/extract, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 14, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 933, :end-line 933, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Generic function to unwrap/extract\n  the inner value of a container."}, sequence {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 781, :column 7, :end-line 781, :end-column 15, :arglists (quote ([mvs])), :doc "Given a collection of monadic values, collect\n  their values in a seq returned in the monadic context.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => #<Just [[2, 3]]>\n\n      (m/sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (m/sequence []))\n      ;; => #<Just [()]>\n  "}, :name cats.core/sequence, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 15, :method-params ([mvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 781, :end-line 781, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mvs])), :doc "Given a collection of monadic values, collect\n  their values in a seq returned in the monadic context.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => #<Just [[2, 3]]>\n\n      (m/sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (m/sequence []))\n      ;; => #<Just [()]>\n  "}, ap {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 480, :column 11, :end-line 480, :end-column 13, :macro true, :arglists (quote ([f & args])), :doc "Apply a pure function to applicative arguments, e.g.\n\n   (ap + (just 1) (just 2) (just 3))\n   ;; => #<Just [6]>\n   (ap str [\"hi\" \"lo\"] [\"bye\" \"woah\" \"hey\"])\n   ;; => [\"hibye\" \"hiwoah\" \"hihey\"\n          \"lobye\" \"lowoah\" \"lohey\"]\n\n   `ap` is essentially sugar for `(apply fapply (pure f) args)`,\n   but for the common case where you have a pure, uncurried,\n   possibly variadic function.\n\n   `ap` actually desugars in `alet` form:\n\n   (macroexpand-1 `(ap + (just 1) (just2)))\n   ;; => (alet [a1 (just 1) a2 (just 2)] (+ a1 a2))\n\n   That way, variadic functions Just Work, without needing to specify\n   an arity separately.\n\n   If you're familiar with Haskell, this is closest to writing\n   \"in Applicative style\": you can straightforwardly convert\n   pure function application to effectful application by with\n   some light syntax (<$> and <*> in case of Haskell, and `ap` here).\n\n   See the original Applicative paper for more inspiration:\n   http://staff.city.ac.uk/~ross/papers/Applicative.pdf", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env f args)], :arglists ([&form &env f & args]), :arglists-meta (nil)}}, :name cats.core/ap, :variadic true, :file ".cljs_node_repl/cats/core.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env f args)], :arglists ([&form &env f & args]), :arglists-meta (nil)}, :method-params [(&form &env f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 480, :macro true, :end-line 480, :max-fixed-arity 3, :fn-var false, :arglists ([&form &env f & args]), :doc "Apply a pure function to applicative arguments, e.g.\n\n   (ap + (just 1) (just 2) (just 3))\n   ;; => #<Just [6]>\n   (ap str [\"hi\" \"lo\"] [\"bye\" \"woah\" \"hey\"])\n   ;; => [\"hibye\" \"hiwoah\" \"hihey\"\n          \"lobye\" \"lowoah\" \"lohey\"]\n\n   `ap` is essentially sugar for `(apply fapply (pure f) args)`,\n   but for the common case where you have a pure, uncurried,\n   possibly variadic function.\n\n   `ap` actually desugars in `alet` form:\n\n   (macroexpand-1 `(ap + (just 1) (just2)))\n   ;; => (alet [a1 (just 1) a2 (just 2)] (+ a1 a2))\n\n   That way, variadic functions Just Work, without needing to specify\n   an arity separately.\n\n   If you're familiar with Haskell, this is closest to writing\n   \"in Applicative style\": you can straightforwardly convert\n   pure function application to effectful application by with\n   some light syntax (<$> and <*> in case of Haskell, and `ap` here).\n\n   See the original Applicative paper for more inspiration:\n   http://staff.city.ac.uk/~ross/papers/Applicative.pdf"}, foldm {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 955, :column 7, :end-line 955, :end-column 12, :arglists (quote ([f z xs] [ctx f z xs])), :doc "Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  ", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f z xs] [ctx f z xs]), :arglists ([f z xs] [ctx f z xs]), :arglists-meta (nil nil)}}, :name cats.core/foldm, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f z xs] [ctx f z xs]), :arglists ([f z xs] [ctx f z xs]), :arglists-meta (nil nil)}, :method-params ([f z xs] [ctx f z xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 955, :end-line 955, :max-fixed-arity 4, :fn-var true, :arglists ([f z xs] [ctx f z xs]), :doc "Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  "}, bindings->batches {:protocol-inline nil, :meta {:file "/home/parker/clojure-script-projects/fermat/.cljs_node_repl/cats/core.cljc", :line 378, :column 8, :end-line 378, :end-column 25, :private true, :arglists (quote ([bindings]))}, :private true, :name cats.core/bindings->batches, :variadic false, :file ".cljs_node_repl/cats/core.cljc", :end-column 25, :method-params ([bindings]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 378, :end-line 378, :max-fixed-arity 1, :fn-var true, :arglists (quote ([bindings]))}}, :cljs.spec/registry-ref [], :require-macros {cats.core cats.core, ctx cats.context, cats.context cats.context}, :cljs.analyzer/constants {:seen #{& :renames :else cljs.core/-> cats.core/fmap do cats.core/ap :syms cats.core/mlet cljs.core/let cats.core/alet cats.core/fapply :aps :seen cats.core/join cljs.core/fn cljs.core/->> :arglists :body cats.core/return}, :order [:else :body :syms :aps :seen :renames cats.core/fmap cljs.core/fn cats.core/fapply do cats.core/join cats.core/alet cats.core/ap cljs.core/let cljs.core/-> cats.core/mlet cats.core/return cljs.core/->> :arglists &]}, :doc "Category Theory abstractions for Clojure"}